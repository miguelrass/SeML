/*
 * generated by Xtext 2.11.0
 */
package org.xtext.seml.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.seml.seML.Assignment;
import org.xtext.seml.seML.BoolVal;
import org.xtext.seml.seML.Characteristic;
import org.xtext.seml.seML.FloatVal;
import org.xtext.seml.seML.FreeIndividual;
import org.xtext.seml.seML.Import;
import org.xtext.seml.seML.ImportModel;
import org.xtext.seml.seML.IntVal;
import org.xtext.seml.seML.MainModel;
import org.xtext.seml.seML.ObjectProperty;
import org.xtext.seml.seML.Relation;
import org.xtext.seml.seML.SeMLPackage;
import org.xtext.seml.seML.StaticIndividual;
import org.xtext.seml.seML.StringVal;
import org.xtext.seml.services.SeMLGrammarAccess;

@SuppressWarnings("all")
public class SeMLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SeMLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SeMLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SeMLPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case SeMLPackage.BOOL_VAL:
				sequence_Value(context, (BoolVal) semanticObject); 
				return; 
			case SeMLPackage.CHARACTERISTIC:
				sequence_Characteristic(context, (Characteristic) semanticObject); 
				return; 
			case SeMLPackage.FLOAT_VAL:
				sequence_Value(context, (FloatVal) semanticObject); 
				return; 
			case SeMLPackage.FREE_INDIVIDUAL:
				sequence_FreeIndividual(context, (FreeIndividual) semanticObject); 
				return; 
			case SeMLPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case SeMLPackage.IMPORT_MODEL:
				sequence_ImportModel(context, (ImportModel) semanticObject); 
				return; 
			case SeMLPackage.INT_VAL:
				sequence_Value(context, (IntVal) semanticObject); 
				return; 
			case SeMLPackage.MAIN_MODEL:
				sequence_MainModel(context, (MainModel) semanticObject); 
				return; 
			case SeMLPackage.OBJECT_PROPERTY:
				sequence_ObjectProperty(context, (ObjectProperty) semanticObject); 
				return; 
			case SeMLPackage.RELATION:
				sequence_Relation(context, (Relation) semanticObject); 
				return; 
			case SeMLPackage.STATIC_INDIVIDUAL:
				sequence_StaticIndividual(context, (StaticIndividual) semanticObject); 
				return; 
			case SeMLPackage.STRING_VAL:
				sequence_Value(context, (StringVal) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Sentence returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (ind=[Individual|ALIAS] literal=Value)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeMLPackage.Literals.ASSIGNMENT__IND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeMLPackage.Literals.ASSIGNMENT__IND));
			if (transientValues.isValueTransient(semanticObject, SeMLPackage.Literals.ASSIGNMENT__LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeMLPackage.Literals.ASSIGNMENT__LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getIndIndividualALIASTerminalRuleCall_0_0_1(), semanticObject.eGet(SeMLPackage.Literals.ASSIGNMENT__IND, false));
		feeder.accept(grammarAccess.getAssignmentAccess().getLiteralValueParserRuleCall_2_0(), semanticObject.getLiteral());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Characteristic returns Characteristic
	 *
	 * Constraint:
	 *     (name=ALIAS iri=STRING)
	 */
	protected void sequence_Characteristic(ISerializationContext context, Characteristic semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeMLPackage.Literals.CHARACTERISTIC__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeMLPackage.Literals.CHARACTERISTIC__NAME));
			if (transientValues.isValueTransient(semanticObject, SeMLPackage.Literals.CHARACTERISTIC__IRI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeMLPackage.Literals.CHARACTERISTIC__IRI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCharacteristicAccess().getNameALIASTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCharacteristicAccess().getIriSTRINGTerminalRuleCall_2_0(), semanticObject.getIri());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Individual returns FreeIndividual
	 *     FreeIndividual returns FreeIndividual
	 *
	 * Constraint:
	 *     (name=ALIAS iri=STRING)
	 */
	protected void sequence_FreeIndividual(ISerializationContext context, FreeIndividual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeMLPackage.Literals.INDIVIDUAL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeMLPackage.Literals.INDIVIDUAL__NAME));
			if (transientValues.isValueTransient(semanticObject, SeMLPackage.Literals.INDIVIDUAL__IRI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeMLPackage.Literals.INDIVIDUAL__IRI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFreeIndividualAccess().getNameALIASTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFreeIndividualAccess().getIriSTRINGTerminalRuleCall_2_0(), semanticObject.getIri());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns ImportModel
	 *     ImportModel returns ImportModel
	 *
	 * Constraint:
	 *     (staticIndividuals+=StaticIndividual+ individualOptions+=FreeIndividual* characteristics+=Characteristic* objectProperties+=ObjectProperty*)
	 */
	protected void sequence_ImportModel(ISerializationContext context, ImportModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeMLPackage.Literals.IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeMLPackage.Literals.IMPORT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns MainModel
	 *     MainModel returns MainModel
	 *
	 * Constraint:
	 *     (imports+=Import+ (useCh+=[Characteristic|ALIAS] useCh+=[Characteristic|ALIAS]*)? sentences+=Sentence*)
	 */
	protected void sequence_MainModel(ISerializationContext context, MainModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObjectProperty returns ObjectProperty
	 *
	 * Constraint:
	 *     (name=ALIAS iri=STRING)
	 */
	protected void sequence_ObjectProperty(ISerializationContext context, ObjectProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeMLPackage.Literals.OBJECT_PROPERTY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeMLPackage.Literals.OBJECT_PROPERTY__NAME));
			if (transientValues.isValueTransient(semanticObject, SeMLPackage.Literals.OBJECT_PROPERTY__IRI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeMLPackage.Literals.OBJECT_PROPERTY__IRI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectPropertyAccess().getNameALIASTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getObjectPropertyAccess().getIriSTRINGTerminalRuleCall_2_0(), semanticObject.getIri());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sentence returns Relation
	 *     Relation returns Relation
	 *
	 * Constraint:
	 *     (ind1=[Individual|ALIAS] obj=[ObjectProperty|ALIAS] ind2+=[Individual|ALIAS] ind2+=[Individual|ALIAS]*)
	 */
	protected void sequence_Relation(ISerializationContext context, Relation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Individual returns StaticIndividual
	 *     StaticIndividual returns StaticIndividual
	 *
	 * Constraint:
	 *     (name=ALIAS iri=STRING)
	 */
	protected void sequence_StaticIndividual(ISerializationContext context, StaticIndividual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeMLPackage.Literals.INDIVIDUAL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeMLPackage.Literals.INDIVIDUAL__NAME));
			if (transientValues.isValueTransient(semanticObject, SeMLPackage.Literals.INDIVIDUAL__IRI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeMLPackage.Literals.INDIVIDUAL__IRI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStaticIndividualAccess().getNameALIASTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStaticIndividualAccess().getIriSTRINGTerminalRuleCall_2_0(), semanticObject.getIri());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns BoolVal
	 *
	 * Constraint:
	 *     val=BOOL
	 */
	protected void sequence_Value(ISerializationContext context, BoolVal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeMLPackage.Literals.BOOL_VAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeMLPackage.Literals.BOOL_VAL__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValueAccess().getValBOOLTerminalRuleCall_1_1_0(), semanticObject.isVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns FloatVal
	 *
	 * Constraint:
	 *     val=FLOAT
	 */
	protected void sequence_Value(ISerializationContext context, FloatVal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeMLPackage.Literals.FLOAT_VAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeMLPackage.Literals.FLOAT_VAL__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValueAccess().getValFLOATTerminalRuleCall_0_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns IntVal
	 *
	 * Constraint:
	 *     val=INT
	 */
	protected void sequence_Value(ISerializationContext context, IntVal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeMLPackage.Literals.INT_VAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeMLPackage.Literals.INT_VAL__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValueAccess().getValINTTerminalRuleCall_2_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns StringVal
	 *
	 * Constraint:
	 *     val=STRING
	 */
	protected void sequence_Value(ISerializationContext context, StringVal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeMLPackage.Literals.STRING_VAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeMLPackage.Literals.STRING_VAL__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValueAccess().getValSTRINGTerminalRuleCall_3_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
}

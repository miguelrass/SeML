/**
 * generated by Xtext 2.10.0
 */
package org.xtext.seml.validation;

import com.google.common.base.Objects;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.swt.graphics.Color;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.validation.ValidationMessageAcceptor;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.rass.ontologies.Anomaly;
import org.rass.ontologies.MasterOntology;
import org.rass.ontologies.Ontologies;
import org.rass.restrictions.CharacteristicsSolver;
import org.rass.restrictions.OptionsHandler;
import org.rass.restrictions.Problem;
import org.semanticweb.owlapi.model.OWLClass;
import org.xtext.seml.Console;
import org.xtext.seml.Progress;
import org.xtext.seml.seML.Assignment;
import org.xtext.seml.seML.Characteristic;
import org.xtext.seml.seML.FreeIndividual;
import org.xtext.seml.seML.Import;
import org.xtext.seml.seML.ImportModel;
import org.xtext.seml.seML.Individual;
import org.xtext.seml.seML.MainModel;
import org.xtext.seml.seML.ObjectProperty;
import org.xtext.seml.seML.Relation;
import org.xtext.seml.seML.SeMLPackage;
import org.xtext.seml.seML.StaticIndividual;
import org.xtext.seml.validation.AbstractSeMLValidator;
import org.xtext.seml.validation.FeaturePlace;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class SeMLValidator extends AbstractSeMLValidator {
  private static String local_log = "Validator Log: ";
  
  public final static String FIX_PROBLEM = "FixProblem";
  
  public static HashMap<String, ArrayList<Problem>> problems;
  
  public static Problem nextProblem = null;
  
  public static MainModel globalMainModel;
  
  public static ImportModel globalImportModel;
  
  public static int validationState = 0;
  
  private long importDate;
  
  private static HashMap<String, FeaturePlace> visibilityMap = null;
  
  private static HashSet<Individual> activeInds = null;
  
  public static HashMap<String, EObject> quickfixMap = null;
  
  private final static Color colorValidating = new Color(null, 237, 237, 237);
  
  private final static Color colorFailed = new Color(null, 255, 196, 196);
  
  private final static Color colorPassed = new Color(null, 221, 255, 219);
  
  public static long solutionsRuntime = 0;
  
  public static long searchRuntime = 0;
  
  private boolean init = false;
  
  @Check(CheckType.FAST)
  public void CheckModelValFast(final MainModel m) {
    try {
      if ((this.init == false)) {
        this.init = true;
        Ontologies.populatePaths(m);
        OptionsHandler.LoadSettings();
      }
      if ((OptionsHandler.validationMode == 0)) {
        this.CheckModelVal(m);
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void CheckModelValNorm(final MainModel m) {
    if ((OptionsHandler.validationMode == 1)) {
      this.CheckModelVal(m);
    }
  }
  
  @Check(CheckType.EXPENSIVE)
  public void CheckModelValExpe(final MainModel m) {
    if ((OptionsHandler.validationMode == 2)) {
      this.CheckModelVal(m);
    }
  }
  
  public void CheckModelVal(final MainModel m) {
    final String local_log = (SeMLValidator.local_log + "[CheckModelVal] ");
    SeMLValidator.validationState = 1;
    Console.ChangeConsole(SeMLValidator.colorValidating, null);
    final EList<Resource.Diagnostic> er = m.eResource().getErrors();
    int _size = er.size();
    boolean _notEquals = (_size != 0);
    if (_notEquals) {
      System.err.println((local_log + "Model contains errors:"));
      final Consumer<Resource.Diagnostic> _function = (Resource.Diagnostic e) -> {
        System.err.println((local_log + e));
      };
      er.forEach(_function);
      SeMLValidator.validationState = 2;
      Console.ChangeConsole(SeMLValidator.colorFailed, null);
      return;
    }
    try {
      boolean _checkModel = this.checkModel(m);
      if (_checkModel) {
        SeMLValidator.validationState = 3;
        Console.ChangeConsole(SeMLValidator.colorPassed, null);
      } else {
        SeMLValidator.validationState = 2;
        Console.ChangeConsole(SeMLValidator.colorFailed, null);
      }
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        SeMLValidator.validationState = 2;
        Console.ChangeConsole(SeMLValidator.colorFailed, null);
        String _string = e.toString();
        String _plus = ((local_log + "Internal Error: ") + _string);
        System.err.println(_plus);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  public boolean checkModel(final MainModel m) {
    final String local_log = (SeMLValidator.local_log + "[checkModel] ");
    boolean _CheckImports = this.CheckImports(m);
    boolean _not = (!_CheckImports);
    if (_not) {
      return false;
    }
    final DateFormat dateFormat = new SimpleDateFormat("HH:mm:ss");
    final Date date = new Date();
    final List<Relation> relationsList = EcoreUtil2.<Relation>getAllContentsOfType(m, Relation.class);
    final List<Assignment> assignmentsList = EcoreUtil2.<Assignment>getAllContentsOfType(m, Assignment.class);
    final EList<Characteristic> useList = m.getUseCh();
    this.GetImportModel(m.eResource(), Ontologies.GENfile_relpath);
    String _format = dateFormat.format(date);
    String _plus = ("Validating model... (" + _format);
    String _plus_1 = (_plus + ")");
    Console.OutPairLn(local_log, _plus_1);
    final long startTime = System.currentTimeMillis();
    final EList<Resource.Diagnostic> er = SeMLValidator.globalImportModel.eResource().getErrors();
    boolean _isEmpty = er.isEmpty();
    boolean _not_1 = (!_isEmpty);
    if (_not_1) {
      Console.ErrPairLn(local_log, "Aborted. Keywords file contains errors:");
      final Consumer<Resource.Diagnostic> _function = (Resource.Diagnostic e) -> {
        System.err.println((local_log + e));
      };
      er.forEach(_function);
      return false;
    }
    MasterOntology.CacheIRIs(SeMLValidator.globalImportModel);
    HashMap<String, EObject> _hashMap = new HashMap<String, EObject>();
    SeMLValidator.quickfixMap = _hashMap;
    final Consumer<StaticIndividual> _function_1 = (StaticIndividual i) -> {
      SeMLValidator.quickfixMap.put(i.getName(), i);
    };
    SeMLValidator.globalImportModel.getStaticIndividuals().forEach(_function_1);
    final Consumer<FreeIndividual> _function_2 = (FreeIndividual i) -> {
      SeMLValidator.quickfixMap.put(i.getName(), i);
    };
    SeMLValidator.globalImportModel.getIndividualOptions().forEach(_function_2);
    final Consumer<ObjectProperty> _function_3 = (ObjectProperty o) -> {
      SeMLValidator.quickfixMap.put(o.getName(), o);
    };
    SeMLValidator.globalImportModel.getObjectProperties().forEach(_function_3);
    HashSet<Individual> _hashSet = new HashSet<Individual>();
    SeMLValidator.activeInds = _hashSet;
    final Consumer<StaticIndividual> _function_4 = (StaticIndividual i) -> {
      SeMLValidator.activeInds.add(i);
    };
    SeMLValidator.globalImportModel.getStaticIndividuals().forEach(_function_4);
    final HashSet<String> freeRefIRIs = new HashSet<String>();
    boolean chainingError = false;
    for (final Relation r : relationsList) {
      {
        boolean _contains = SeMLValidator.activeInds.contains(r.getInd1());
        boolean _not_2 = (!_contains);
        if (_not_2) {
          this.error("Individual is not static nor previously referenced.", r, SeMLPackage.Literals.RELATION__IND1);
          chainingError = true;
        }
        SeMLValidator.activeInds.addAll(r.getInd2());
        final Consumer<Individual> _function_5 = (Individual i) -> {
          if ((i instanceof FreeIndividual)) {
            freeRefIRIs.add(((FreeIndividual)i).getIri());
          }
        };
        r.getInd2().forEach(_function_5);
      }
    }
    for (final Assignment a : assignmentsList) {
      boolean _contains = SeMLValidator.activeInds.contains(a.getInd());
      boolean _not_2 = (!_contains);
      if (_not_2) {
        this.error("Individual is not static nor referenced.", a, SeMLPackage.Literals.ASSIGNMENT__IND);
        chainingError = true;
      }
    }
    if (chainingError) {
      Console.ErrPairLn(local_log, "Aborted. Chaining inconsistency detected.");
      return false;
    }
    HashMap<String, FeaturePlace> _hashMap_1 = new HashMap<String, FeaturePlace>();
    SeMLValidator.visibilityMap = _hashMap_1;
    if ((useList != null)) {
      for (int i = 0; (i < ((Object[])Conversions.unwrapArray(useList, Object.class)).length); i++) {
        String _name = useList.get(i).getName();
        FeaturePlace _featurePlace = new FeaturePlace(m, SeMLPackage.Literals.MAIN_MODEL__USE_CH, i);
        SeMLValidator.visibilityMap.put(_name, _featurePlace);
      }
    }
    for (final Relation r_1 : relationsList) {
      {
        String _name = r_1.getInd1().getName();
        FeaturePlace _featurePlace = new FeaturePlace(r_1, SeMLPackage.Literals.RELATION__IND1);
        SeMLValidator.visibilityMap.put(_name, _featurePlace);
        for (int i = 0; (i < r_1.getInd2().size()); i++) {
          String _name_1 = r_1.getInd2().get(i).getName();
          FeaturePlace _featurePlace_1 = new FeaturePlace(r_1, SeMLPackage.Literals.RELATION__IND2, i);
          SeMLValidator.visibilityMap.put(_name_1, _featurePlace_1);
        }
      }
    }
    for (final Assignment a_1 : assignmentsList) {
      String _name = a_1.getInd().getName();
      FeaturePlace _featurePlace = new FeaturePlace(a_1, SeMLPackage.Literals.ASSIGNMENT__IND);
      SeMLValidator.visibilityMap.put(_name, _featurePlace);
    }
    try {
      File _file = new File((Ontologies.GENfolder + Ontologies.masterNAME));
      MasterOntology.loadMasterOntology(_file, freeRefIRIs);
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        String _message = e.getMessage();
        String _plus_2 = ("Aborted. Error loading master ontology file: " + _message);
        Console.ErrPairLn(local_log, _plus_2);
        return false;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    System.out.println((local_log + "Adding relations to ontology..."));
    MasterOntology.AddOPRelations(relationsList);
    MasterOntology.AddDPRelations(assignmentsList);
    boolean _ReasonAndExplainMaster = MasterOntology.ReasonAndExplainMaster();
    if (_ReasonAndExplainMaster) {
      this.RouteIssueToAgent(m, Anomaly.getAnomalies(), 1);
      Console.ErrPairLn(local_log, "Aborted. Ontology is inconsistent or has unsatisfiabilities.");
      return false;
    }
    EObject eo = null;
    EStructuralFeature sf = null;
    try {
      boolean _isEmpty_1 = useList.isEmpty();
      if (_isEmpty_1) {
        eo = IterableExtensions.<Import>last(m.getImports());
        sf = SeMLPackage.Literals.IMPORT__NAME;
      } else {
        eo = m;
        sf = SeMLPackage.Literals.MAIN_MODEL__USE_CH;
      }
      boolean _BuildMastersCharacteristicsTree = MasterOntology.BuildMastersCharacteristicsTree(useList);
      boolean _not_3 = (!_BuildMastersCharacteristicsTree);
      if (_not_3) {
        this.error(("There are unsolved Characteristics variabilites: \n" + CharacteristicsSolver.chrProblem), eo, sf);
        Console.ErrPairLn(local_log, "Aborted. Unsolved Characteristics variabilites.");
        return false;
      }
    } catch (final Throwable _t_1) {
      if (_t_1 instanceof Exception) {
        final Exception e_1 = (Exception)_t_1;
        this.error(e_1.getMessage(), eo, sf);
        Console.ErrPairLn(local_log, "Aborted. Characteristics inconsistency.");
        return false;
      } else {
        throw Exceptions.sneakyThrow(_t_1);
      }
    }
    MasterOntology.AddChIndividuals(CharacteristicsSolver.GetRequiredCharacteristics());
    boolean _ReasonAndExplainMaster_1 = MasterOntology.ReasonAndExplainMaster();
    if (_ReasonAndExplainMaster_1) {
      this.RouteIssueToAgent(m, Anomaly.getAnomalies(), 1);
      Console.ErrPairLn(local_log, "Aborted. Characteristics generated inconsistencies.");
      return false;
    }
    SeMLValidator.globalMainModel = m;
    final HashSet<List<String>> authorizatedRels = new HashSet<List<String>>();
    System.out.println((local_log + "Checking characteristics and individuals\' restrictions"));
    SeMLValidator.solutionsRuntime = 0;
    SeMLValidator.searchRuntime = 0;
    long _currentTimeMillis = System.currentTimeMillis();
    final long elapsedLoadingTime = (_currentTimeMillis - startTime);
    boolean _CheckModelRestrictions = SeMLValidator.CheckModelRestrictions(false, authorizatedRels);
    boolean _not_4 = (!_CheckModelRestrictions);
    if (_not_4) {
      final String label = "The model does not require this relation: ";
      boolean ok = true;
      MasterOntology.ExtendAuthorizations(authorizatedRels);
      for (final Relation r_2 : relationsList) {
        EList<Individual> _ind2 = r_2.getInd2();
        for (final Individual i : _ind2) {
          {
            final List<String> list = Arrays.<String>asList(r_2.getInd1().getName(), r_2.getObj().getName(), i.getName());
            boolean _contains_1 = authorizatedRels.contains(list);
            boolean _not_5 = (!_contains_1);
            if (_not_5) {
              this.error((label + list), r_2, SeMLPackage.Literals.RELATION__OBJ);
              ok = false;
            }
          }
        }
      }
      for (final Assignment a_2 : assignmentsList) {
        {
          final String i_1 = a_2.getInd().getName();
          final List<String> list = Arrays.<String>asList(i_1);
          boolean _contains_1 = authorizatedRels.contains(list);
          boolean _not_5 = (!_contains_1);
          if (_not_5) {
            this.error(((label + i_1) + " = literal"), a_2, SeMLPackage.Literals.ASSIGNMENT__IND);
            ok = false;
          }
        }
      }
      if ((!ok)) {
        Console.ErrPairLn(local_log, "Aborted. Unauthorized relation(s).");
        return false;
      }
    }
    String fixAll = null;
    HashSet<FeaturePlace> fixAllEOs = new HashSet<FeaturePlace>();
    boolean hasErrors = false;
    Set<Map.Entry<String, ArrayList<Problem>>> _entrySet = SeMLValidator.problems.entrySet();
    for (final Map.Entry<String, ArrayList<Problem>> ps : _entrySet) {
      {
        Import _last = IterableExtensions.<Import>last(m.getImports());
        final FeaturePlace DefaultFP = new FeaturePlace(_last, SeMLPackage.Literals.IMPORT__NAME);
        final FeaturePlace f = SeMLValidator.visibilityMap.getOrDefault(ps.getKey(), DefaultFP);
        int cnt = 0;
        ArrayList<Problem> _value = ps.getValue();
        for (final Problem p : _value) {
          {
            if ((Objects.equal(p.type, Problem.TypeE.SOLVED) && (!fixAllEOs.contains(f)))) {
              fixAllEOs.add(f);
              fixAll = "F";
            } else {
              fixAll = "";
            }
            int _size = p.solutions.size();
            int _plus_3 = (_size + 1);
            final String[] args = new String[_plus_3];
            args[0] = fixAll;
            for (int i_1 = 1; (i_1 < ((List<String>)Conversions.doWrapArray(args)).size()); i_1++) {
              args[i_1] = IterableExtensions.join(p.solutions.get((i_1 - 1)), ",");
            }
            final Problem.LevelE _switchValue = p.level;
            if (_switchValue != null) {
              switch (_switchValue) {
                case ERROR:
                  this.error(p.GetLabel(), f.eo, f.sf, f.index, SeMLValidator.FIX_PROBLEM, args);
                  hasErrors = true;
                  break;
                case WARNING:
                  this.warning(p.GetLabel(), f.eo, f.sf, f.index, SeMLValidator.FIX_PROBLEM, args);
                  break;
                case INFO:
                  this.info(p.GetLabel(), f.eo, f.sf, f.index, SeMLValidator.FIX_PROBLEM, args);
                  break;
                default:
                  break;
              }
            }
          }
        }
      }
    }
    long _currentTimeMillis_1 = System.currentTimeMillis();
    final long elapsedTime = (_currentTimeMillis_1 - startTime);
    final int solutionsTime = ((int) ((((float) SeMLValidator.solutionsRuntime) / elapsedTime) * 100f));
    final int searchTime = ((int) ((((float) SeMLValidator.searchRuntime) / elapsedTime) * 100f));
    final int loadingTime = ((int) ((((float) elapsedLoadingTime) / elapsedTime) * 100f));
    String _plus_3 = (Long.valueOf((elapsedTime / 1000)) + "s (");
    String _plus_4 = (_plus_3 + Integer.valueOf(loadingTime));
    String _plus_5 = (_plus_4 + "% loading, ");
    String _plus_6 = (_plus_5 + Integer.valueOf(searchTime));
    String _plus_7 = (_plus_6 + "% search, ");
    String _plus_8 = (_plus_7 + Integer.valueOf(solutionsTime));
    final String relativeTime = (_plus_8 + "% solutions)");
    if (hasErrors) {
      Console.OutPair(local_log, "Done. Model has errors.  ");
      Console.DebLn(relativeTime);
      return false;
    }
    Console.OutPair(local_log, "Done. Model is valid.  ");
    Console.DebLn(relativeTime);
    return true;
  }
  
  /**
   * Check characteristic imposed restrictions, individual restrictions & Reports
   * @return true if excess errors exist
   */
  public static boolean CheckModelRestrictions(final boolean skipFullTest, final HashSet<List<String>> authorizatedRels) {
    SeMLValidator.nextProblem = null;
    HashMap<String, ArrayList<Problem>> _hashMap = new HashMap<String, ArrayList<Problem>>();
    SeMLValidator.problems = _hashMap;
    int _GetCharacteristicsSize = CharacteristicsSolver.GetCharacteristicsSize();
    int _size = SeMLValidator.activeInds.size();
    final int workload = (_GetCharacteristicsSize + _size);
    final Progress pm = new Progress(workload, "Validating Model", "Checking consistency");
    Set<OWLClass> _GetRequiredCharacteristics = CharacteristicsSolver.GetRequiredCharacteristics();
    for (final OWLClass ch : _GetRequiredCharacteristics) {
      {
        String _GetShortIRI = Ontologies.GetShortIRI(ch.getIRI());
        String _plus = ("Checking \"" + _GetShortIRI);
        String _plus_1 = (_plus + "\" imposed restrictions");
        pm.subTask = _plus_1;
        final ArrayList<Problem> ps = MasterOntology.CheckModelRestrictions(ch);
        boolean _isEmpty = ps.isEmpty();
        boolean _not = (!_isEmpty);
        if (_not) {
          if (skipFullTest) {
            boolean _FindNextProblem = SeMLValidator.FindNextProblem(ps);
            if (_FindNextProblem) {
              pm.stop();
              return false;
            }
          }
          SeMLValidator.problems.put(MasterOntology.cachedIRIs.get(ch.getIRI().toString()), ps);
        }
        pm.state++;
      }
    }
    final Function1<Map.Entry<String, ArrayList<Problem>>, Boolean> _function = (Map.Entry<String, ArrayList<Problem>> e) -> {
      final Function1<Problem, Boolean> _function_1 = (Problem p) -> {
        return Boolean.valueOf(Objects.equal(p.type, Problem.TypeE.CHAR_EXCESS));
      };
      return Boolean.valueOf(IterableExtensions.<Problem>exists(e.getValue(), _function_1));
    };
    boolean _exists = IterableExtensions.<Map.Entry<String, ArrayList<Problem>>>exists(SeMLValidator.problems.entrySet(), _function);
    if (_exists) {
      pm.stop();
      return true;
    }
    for (final Individual i : SeMLValidator.activeInds) {
      {
        String _name = i.getName();
        String _plus = ("Checking \"" + _name);
        String _plus_1 = (_plus + "\" restrictions and reports");
        pm.subTask = _plus_1;
        ArrayList<Problem> ps = MasterOntology.CheckRelationRestrictions(authorizatedRels, i.getIri());
        if (skipFullTest) {
          boolean _FindNextProblem = SeMLValidator.FindNextProblem(ps);
          if (_FindNextProblem) {
            pm.stop();
            return false;
          }
        }
        MasterOntology.CheckReports(i.getIri(), ps);
        boolean _isEmpty = ps.isEmpty();
        boolean _not = (!_isEmpty);
        if (_not) {
          SeMLValidator.problems.put(i.getName(), ps);
        }
        pm.state++;
      }
    }
    return false;
  }
  
  /**
   * Searches for a SOLVED Problem
   * @return true if it is found
   */
  public static boolean FindNextProblem(final ArrayList<Problem> ps) {
    for (final Problem p : ps) {
      boolean _equals = Objects.equal(p.type, Problem.TypeE.SOLVED);
      if (_equals) {
        SeMLValidator.nextProblem = p;
        return true;
      }
    }
    return false;
  }
  
  /**
   * Very basic function to dispatch the issue to its agent (uses every visible individual)
   */
  public void RouteIssueToAgent(final MainModel m, final String issue, final int type) {
    Set<Map.Entry<String, FeaturePlace>> _entrySet = SeMLValidator.visibilityMap.entrySet();
    for (final Map.Entry<String, FeaturePlace> i : _entrySet) {
      boolean _contains = issue.contains(i.getKey());
      if (_contains) {
        this.DisplayAnomalies((" (related with this individual):\n" + issue), i.getValue().eo, i.getValue().sf, i.getValue().index, type);
        return;
      }
    }
    this.DisplayAnomalies((":\n" + issue), IterableExtensions.<Import>last(m.getImports()), SeMLPackage.Literals.IMPORT__NAME, ValidationMessageAcceptor.INSIGNIFICANT_INDEX, type);
  }
  
  public void DisplayAnomalies(final String s, final EObject eo, final EStructuralFeature eRef, final int index, final int type) {
    switch (type) {
      case 1:
        this.error(("Anomaly" + s), eo, eRef, index);
        break;
      case 2:
        this.error(("Error" + s), eo, eRef, index);
        break;
      case 3:
        this.warning(("Warning" + s), eo, eRef, index);
        break;
      case 4:
        this.info(("Information" + s), eo, eRef, index);
        break;
    }
  }
  
  /**
   * Load and parse ImportModel. This method loads the file on-demand
   * if the model contains no cross-references.
   * 
   * @param contextResource		Absolute file path of the ImportsModel
   * @param importURIAsString		Absolute file path of the ImportsModel
   */
  public void GetImportModel(final Resource contextResource, final String importURIAsString) {
    Resource resource = SeMLValidator.ImportResource(contextResource, importURIAsString);
    if ((resource == null)) {
      String _absolutePath = Ontologies.GENfile.getAbsolutePath();
      String _plus = ("Error loading keywords file: " + _absolutePath);
      this.error(_plus, IterableExtensions.<Import>last(SeMLValidator.globalMainModel.getImports()), SeMLPackage.Literals.IMPORT__NAME);
      return;
    }
    boolean _equals = Long.valueOf(resource.getTimeStamp()).equals(Long.valueOf(this.importDate));
    boolean _not = (!_equals);
    if (_not) {
      resource.unload();
      resource = SeMLValidator.ImportResource(contextResource, importURIAsString);
    }
    TreeIterator<EObject> _allContents = null;
    if (resource!=null) {
      _allContents=resource.getAllContents();
    }
    EObject _head = null;
    if (_allContents!=null) {
      _head=IteratorExtensions.<EObject>head(_allContents);
    }
    SeMLValidator.globalImportModel = ((ImportModel) _head);
  }
  
  /**
   * Load Resource
   */
  public static Resource ImportResource(final Resource contextResource, final String importURIAsString) {
    URI _createURI = null;
    if (URI.class!=null) {
      _createURI=URI.createURI(importURIAsString);
    }
    final URI importURI = _createURI;
    URI _uRI = null;
    if (contextResource!=null) {
      _uRI=contextResource.getURI();
    }
    final URI contextURI = _uRI;
    URI _resolve = null;
    if (importURI!=null) {
      _resolve=importURI.resolve(contextURI);
    }
    final URI resolvedURI = _resolve;
    ResourceSet _resourceSet = null;
    if (contextResource!=null) {
      _resourceSet=contextResource.getResourceSet();
    }
    final ResourceSet contextResourceSet = _resourceSet;
    Resource _resource = null;
    if (contextResourceSet!=null) {
      _resource=contextResourceSet.getResource(resolvedURI, true);
    }
    Resource resource = _resource;
    return resource;
  }
  
  /**
   * Auxiliary function of checkModel, to check imports and create the master ontology
   * 
   * @param m		MainModel
   * @return		True if imports are valid
   */
  public boolean CheckImports(final MainModel m) {
    final String local_log = (SeMLValidator.local_log + "[checkModelImports] ");
    long mostRecentFile = 0;
    boolean _isEmpty = m.getImports().isEmpty();
    if (_isEmpty) {
      return false;
    }
    final String[] pathslist = new String[((Object[])Conversions.unwrapArray(m.getImports(), Object.class)).length];
    int cnt = 0;
    EList<Import> _imports = m.getImports();
    for (final Import i : _imports) {
      {
        String _name = i.getName();
        final File ontfile = new File(_name);
        if (((!ontfile.exists()) || ontfile.isDirectory())) {
          this.error("Ontology file was not found", i, SeMLPackage.Literals.IMPORT__NAME);
          return false;
        }
        long _lastModified = ontfile.lastModified();
        boolean _lessThan = (mostRecentFile < _lastModified);
        if (_lessThan) {
          mostRecentFile = ontfile.lastModified();
        }
        int _plusPlus = cnt++;
        pathslist[_plusPlus] = i.getName();
      }
    }
    Arrays.sort(pathslist);
    if ((Ontologies.GENfile.exists() && Ontologies.GENfile.isFile())) {
      this.importDate = Ontologies.GENfile.lastModified();
      int _compareTo = Long.valueOf(mostRecentFile).compareTo(Long.valueOf(this.importDate));
      boolean _lessThan = (_compareTo < 0);
      if (_lessThan) {
        try {
          final FileInputStream fis = new FileInputStream(Ontologies.GENfile);
          InputStreamReader _inputStreamReader = new InputStreamReader(fis, "UTF-8");
          final BufferedReader br = new BufferedReader(_inputStreamReader);
          String line = br.readLine();
          cnt = 0;
          int SourceFilesNo = Integer.parseInt(line.substring(Ontologies.GENfirstline.length()));
          boolean different = false;
          int _size = ((List<String>)Conversions.doWrapArray(pathslist)).size();
          boolean _equals = (_size == SourceFilesNo);
          if (_equals) {
            while ((!Objects.equal((line = br.readLine()), "*/"))) {
              int _plusPlus = cnt++;
              boolean _equals_1 = pathslist[_plusPlus].equals(line);
              boolean _not = (!_equals_1);
              if (_not) {
                different = true;
              }
            }
            if ((!different)) {
              final File masterfile = new File((Ontologies.GENfolder + Ontologies.masterNAME));
              if ((masterfile.exists() && masterfile.isFile())) {
                br.close();
                return true;
              } else {
                Console.OutPairLn(local_log, "Master Ontology file was deleted. Creating a new one...");
              }
            } else {
              Console.OutPairLn(local_log, "Ontology sources have changed. Updating DSL keywords...");
            }
          } else {
            Console.OutPairLn(local_log, "Number of ontology sources has changed. Updating DSL keywords...");
          }
          br.close();
        } catch (final Throwable _t) {
          if (_t instanceof Exception) {
            final Exception e = (Exception)_t;
            String _message = e.getMessage();
            String _plus = ("Error while reading generated file: " + _message);
            Console.OutPairLn(local_log, _plus);
            Console.OutPairLn(local_log, "Repairing file...");
          } else {
            throw Exceptions.sneakyThrow(_t);
          }
        }
      } else {
        Console.OutPairLn(local_log, "Changes in ontologies detected. Updating DSL keywords...");
      }
    } else {
      Console.OutPairLn(local_log, "Importing DSL keywords for the first time...");
    }
    try {
      Ontologies.ParseOntologies(pathslist);
      this.importDate = Ontologies.GENfile.lastModified();
    } catch (final Throwable _t_1) {
      if (_t_1 instanceof IOException) {
        final IOException e_1 = (IOException)_t_1;
        String _message_1 = e_1.getMessage();
        String _plus_1 = (local_log + _message_1);
        System.out.println(_plus_1);
        this.error(e_1.getMessage(), IterableExtensions.<Import>last(m.getImports()), SeMLPackage.Literals.IMPORT__NAME);
        return false;
      } else {
        throw Exceptions.sneakyThrow(_t_1);
      }
    }
    return true;
  }
  
  public static boolean PopulateQuickFixMap(final MainModel m) {
    try {
      Ontologies.populatePaths(m);
      final Resource resource = SeMLValidator.ImportResource(m.eResource(), Ontologies.GENfile_relpath);
      if (((resource == null) || (!resource.getErrors().isEmpty()))) {
        return false;
      }
      HashMap<String, EObject> _hashMap = new HashMap<String, EObject>();
      SeMLValidator.quickfixMap = _hashMap;
      TreeIterator<EObject> _allContents = null;
      if (resource!=null) {
        _allContents=resource.getAllContents();
      }
      EObject _head = null;
      if (_allContents!=null) {
        _head=IteratorExtensions.<EObject>head(_allContents);
      }
      final ImportModel impModel = ((ImportModel) _head);
      final Consumer<StaticIndividual> _function = (StaticIndividual i) -> {
        SeMLValidator.quickfixMap.put(i.getName(), i);
      };
      impModel.getStaticIndividuals().forEach(_function);
      final Consumer<FreeIndividual> _function_1 = (FreeIndividual i) -> {
        SeMLValidator.quickfixMap.put(i.getName(), i);
      };
      impModel.getIndividualOptions().forEach(_function_1);
      final Consumer<ObjectProperty> _function_2 = (ObjectProperty o) -> {
        SeMLValidator.quickfixMap.put(o.getName(), o);
      };
      impModel.getObjectProperties().forEach(_function_2);
      return true;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}

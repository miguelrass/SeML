/*
 * generated by Xtext 2.10.0
 */
package org.xtext.seml.validation

import com.hp.hpl.jena.ontology.impl.IndividualImpl
import java.io.BufferedReader
import java.io.File
import java.io.FileInputStream
import java.io.IOException
import java.io.InputStreamReader
import java.text.DateFormat
import java.text.SimpleDateFormat
import java.util.ArrayList
import java.util.Arrays
import java.util.Date
import java.util.HashMap
import java.util.HashSet
import java.util.List
import java.util.Set
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.Resource.Diagnostic
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType
import org.rass.ontologies.Anomaly
import org.rass.ontologies.MasterOntology
import org.rass.ontologies.Ontologies
import org.rass.restrictions.CharacteristicsSolver
import org.semanticweb.owlapi.model.OWLClass
import org.xtext.seml.Console
import org.xtext.seml.seML.ImportModel
import org.xtext.seml.seML.MainModel
import org.xtext.seml.seML.Relation
import org.xtext.seml.seML.SeMLPackage
import org.xtext.seml.seML.impl.CharacteristicImpl
import org.xtext.seml.seML.impl.ImportImpl
import org.xtext.seml.seML.Individual
import org.xtext.seml.seML.Assignment
import org.xtext.seml.seML.FreeIndividual
import java.util.Map.Entry
import org.eclipse.xtext.validation.ValidationMessageAcceptor
import org.rass.restrictions.Problem
import org.rass.restrictions.Problem.TypeE
import org.semanticweb.owlapi.model.OWLNamedIndividual
import org.rass.ontologies.MasterCache
import java.beans.FeatureDescriptor
import org.eclipse.swt.graphics.Color
import org.xtext.seml.Progress
import org.rass.restrictions.OptionsHandler

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SeMLValidator extends AbstractSeMLValidator {
	
	static String local_log = "Validator Log: ";

	public static val FIX_PROBLEM = "FixProblem";
	
	public static var HashMap<String, ArrayList<Problem>> problems; //Restriction based problems by Alias
	public static var Problem nextProblem = null; //Most important problem
	public static var MainModel globalMainModel; //To be accessed by the Model Solution
	public static var ImportModel globalImportModel; //To be accessed by the Model Solution

	public static var int validationState = 0; //0-Initial state, 1-Validating, 2-Failed, 3-Passed
	private var long importDate; //Import SeML file's last modified date
	
	//Create map of all visible elements by alias (for error/warning purposes) (individuals)
	private static var HashMap<String,FeaturePlace> visibilityMap = null;
	
	/**
	 * Create list of active individuals (static + referenced)
	 * This variable is populated when the model is validated (and checked against chaining errors)
	 * It is also updated when the QuickFix runs
	 */
	private static var HashSet<Individual> activeInds = null; 
	
	//Create map of imported individuals and object properties by alias for Quickfix
	public static var HashMap<String,EObject> quickfixMap = null;
	
	//private static val Color colorDefault = new Color(null, 255, 255, 255);
	private static val Color colorValidating = new Color(null, 237, 237, 237);
	private static val Color colorFailed = new Color(null, 255, 196, 196);
	private static val Color colorPassed = new Color(null, 221, 255, 219);
	
	//Runtimes of different SeML features
	public static var long solutionsRuntime = 0;
	public static var long searchRuntime = 0;
	
	//Flag to check whether it is the first time a validator is executed
	private boolean init = false;
	
	@Check(CheckType.FAST) 	
	def CheckModelValFast(MainModel m){ 
		
		if(init==false) {init=true; 			
			Ontologies.populatePaths(m);//Generate paths for current SEML file and generated SEML file
			OptionsHandler.LoadSettings();
		}
		if(OptionsHandler.validationMode == 0) CheckModelVal(m);
	}
	@Check(CheckType.NORMAL) 	def CheckModelValNorm(MainModel m){ if(OptionsHandler.validationMode == 1) CheckModelVal(m); }
	@Check(CheckType.EXPENSIVE) def CheckModelValExpe(MainModel m){ if(OptionsHandler.validationMode == 2) CheckModelVal(m); }

	def CheckModelVal(MainModel m){
		val String local_log = local_log + "[CheckModelVal] ";
		validationState = 1;
		Console.ChangeConsole(colorValidating, null);

		val EList<Diagnostic> er = m.eResource.errors
		if(er.size != 0){
			System.err.println(local_log + "Model contains errors:")
			er.forEach[e | System.err.println(local_log + e)]
			validationState = 2;
			Console.ChangeConsole(colorFailed, null);
			return
		}
		
		try {
			if(checkModel(m)) {validationState = 3; Console.ChangeConsole(colorPassed, null);} 
				else {validationState = 2; Console.ChangeConsole(colorFailed, null);}
		} catch (Exception e) {
			validationState = 2;
			Console.ChangeConsole(colorFailed, null);
			System.err.println(local_log + "Internal Error: " + e.toString)
		}
	}
	
	
	def boolean checkModel(MainModel m){
		val String local_log = local_log + "[checkModel] ";
		if(!CheckImports(m)) return false; //return if imports are invalid
		
		val DateFormat dateFormat = new SimpleDateFormat("HH:mm:ss");
	    val Date date = new Date();
	    
	    //========================================================================================= Prepare Environment
        //=============================================================================================================
	    
		//Check if individuals are used without being static or referenced
		val relationsList = EcoreUtil2.getAllContentsOfType(m, Relation);
		//if(!CheckRelationsOrder(relationsList)) return;
		val assignmentsList =	EcoreUtil2.getAllContentsOfType(m, Assignment);
		val useList = 		m.useCh;		
		
		//Import keywords file
		GetImportModel(m.eResource, Ontologies.GENfile_relpath);
		Console.OutPairLn(local_log, "Validating model... ("+dateFormat.format(date)+")");
		val long startTime = System.currentTimeMillis(); //log validation time	
		
		//Check import file for errors
		val EList<Diagnostic> er = globalImportModel.eResource.errors
		if(!er.empty){
			Console.ErrPairLn(local_log, "Aborted. Keywords file contains errors:")
			er.forEach[e | System.err.println(local_log + e)]
			return false
		}
		MasterOntology.CacheIRIs(globalImportModel); 
		
		//============================================================================= Create objects map for Quickfix
        //=============================================================================================================
        
		quickfixMap = new HashMap<String,EObject>();
		
		globalImportModel.staticIndividuals.forEach[i| quickfixMap.put(i.name, i)];
		globalImportModel.individualOptions.forEach[i| quickfixMap.put(i.name, i)];
		globalImportModel.objectProperties.forEach[o | quickfixMap.put(o.name, o)];
		globalImportModel.characteristics.forEach[c | quickfixMap.put(c.name, c)];

		//================================================================================ Check non-ontological errors
        //=============================================================================================================
        
        //Create list of active individuals (static + referenced)
		activeInds = new HashSet<Individual>();
		
		//Add static individuals
		globalImportModel.staticIndividuals.forEach[i | activeInds.add(i)];
		
        //Create list of free referenced individuals
        val freeRefIRIs = new HashSet<String>();
        
		//Check Individuals chaining 
		var boolean chainingError = false;
		for(r : relationsList){
			if(!activeInds.contains(r.ind1)){
				error("Individual is not static nor previously referenced.", r, SeMLPackage.Literals.RELATION__IND1);
				chainingError = true;
			} 
			activeInds.addAll(r.ind2); //add every referenced instance
			r.ind2.forEach[i| if(i instanceof FreeIndividual) freeRefIRIs.add(i.iri)];
		}
		
		//Check Assignments chaining
		for(a : assignmentsList){
			if(!activeInds.contains(a.ind)){
				error("Individual is not static nor referenced.", a, SeMLPackage.Literals.ASSIGNMENT__IND);
				chainingError = true;
			} 
		}
		
		//Abort if any error was thrown
		if(chainingError){
			Console.ErrPairLn(local_log, "Aborted. Chaining inconsistency detected."); return false;
		}
			
		//================================================================= Create visibility map for error declaration
        //=============================================================================================================
		
		//Create map of all visible elements by alias (for error/warning purposes) (individuals)
        visibilityMap = new HashMap<String,FeaturePlace>();
        
        //Add characteristics
        if(useList !== null)
        	for(var int i=0; i<useList.length; i++)
        		visibilityMap.put(useList.get(i).name, new FeaturePlace(m, SeMLPackage.Literals.MAIN_MODEL__USE_CH, i));
        
        //Add individuals
		for(r : relationsList){
			//reason: some static individuals may never be referenced on the right side
			visibilityMap.put(r.ind1.name, new FeaturePlace(r, SeMLPackage.Literals.RELATION__IND1));

			for(var int i=0; i<r.ind2.size; i++){
				visibilityMap.put(r.ind2.get(i).name, new FeaturePlace(r, SeMLPackage.Literals.RELATION__IND2, i));
			}
		}
		for(a : assignmentsList){//reason: some static individuals may never be referenced in OP relations
			visibilityMap.put(a.ind.name, new FeaturePlace(a, SeMLPackage.Literals.ASSIGNMENT__IND));
		}

		//==================================================================================== Check ontological errors
        //=============================================================================================================
        
        //Load Master (with referenced individuals) and initialize OWLAPI objects
		try { 
			MasterOntology.loadMasterOntology(new File(Ontologies.GENfolder + Ontologies.masterNAME), freeRefIRIs);
		} catch (Exception e) {
			Console.ErrPairLn(local_log, "Aborted. Error loading master ontology file: " + e.message); return false;
		}	
		
		//Add all relations to master ontology
		System.out.println(local_log + "Adding relations to ontology...");
		MasterOntology.AddOPRelations(relationsList);
		MasterOntology.AddDPRelations(assignmentsList);
		
		//------------------------------------------------- Check consistency errors before using reasoner
		//Individual restrictions excess error are detected here (open world)

		//Reason (if inconsistent, explain and return)
		if(MasterOntology.ReasonAndExplainMaster()){
			RouteIssueToAgent(m, Anomaly.getAnomalies(), 1);
			Console.ErrPairLn(local_log, "Aborted. Ontology is inconsistent or has unsatisfiabilities."); return false;
		}
		
		//------------------------------------------------- Gather all required characteristics

		//Build characteristics tree (at least, the default characteristic is used)
		var EObject eo; var EStructuralFeature sf;
		try {
			//If the are no "use sentences", use the last import as agent
			if(useList.isEmpty){eo = m.imports.last; sf = SeMLPackage.Literals.IMPORT__NAME;} 
			else{eo = m; sf = SeMLPackage.Literals.MAIN_MODEL__USE_CH;}
			
			if(!MasterOntology.BuildMastersCharacteristicsTree(useList)){ 
				error("There are unsolved Characteristics variabilites: \n" +  CharacteristicsSolver.chrProblem, eo, sf,FIX_PROBLEM, CharacteristicsSolver.chrSolutions);
				Console.ErrPairLn(local_log, "Aborted. Unsolved Characteristics variabilites.");
				return false;
			}	
		} catch (Exception e) {
			error(e.getMessage, eo, sf);
			Console.ErrPairLn(local_log, "Aborted. Characteristics inconsistency.");
			return false;
		}
		
		//------------------------------------------------- Display all required characteristics

		val StringBuilder chStr = new StringBuilder(200); //list of characteristics
		chStr.append("Characteristics being used: ");
		CharacteristicsSolver.GetRequiredCharacteristics.forEach(ch | chStr.append(MasterOntology.cachedIRIs.get(ch.getIRI().toString()) + ", "));
		Console.DebPairLn(local_log, chStr.substring(0, chStr.length()-2));

				
		//------------------------------------------------- Add Characteristic individuals to ontology and check consistency (SWRL)
		
		MasterOntology.AddChIndividuals(CharacteristicsSolver.GetRequiredCharacteristics);
		
		//Reason (if inconsistent, explain and return)
		if(MasterOntology.ReasonAndExplainMaster()){
			RouteIssueToAgent(m, Anomaly.getAnomalies(), 1);
			Console.ErrPairLn(local_log, "Aborted. Characteristics generated inconsistencies."); return false;
		}
		
		//------------------------------------------------- Check restrictions and gather authorizations

		//Save pointer to main model for Quickfix
		globalMainModel = m;
		
		//List with all relations which are authorized by restrictions (OP except max/only)(DP some/only)
	    val HashSet<List<String>> authorizatedRels = new HashSet<List<String>>(); //Aliases: Ind1,Obj,Ind2 or Ind1 (assignment)
		
		System.out.println(local_log + "Checking characteristics and individuals' restrictions");
		solutionsRuntime = 0; //reset solutions runtime
		searchRuntime = 0;
		val elapsedLoadingTime = System.currentTimeMillis() - startTime;
		
		if(!CheckModelRestrictions(false, authorizatedRels)){
	
			//------------------------------------------------- Check authorizations (if there are no characteristic excess errors)
		
			val String label = "The model does not require this relation: ";
			var boolean ok = true;
			
			MasterOntology.ExtendAuthorizations(authorizatedRels); //add sub-properties to list
			
			for(r : relationsList) for(i : r.ind2){ //Check every relation in each sentence
				val list = Arrays.asList(r.ind1.name, r.obj.name, i.name);
				if(!authorizatedRels.contains(list)) {error(label+list,r,SeMLPackage.Literals.RELATION__OBJ); ok=false;}
			}
			
			for(a : assignmentsList){
				val i = a.ind.name; val list = Arrays.asList(i);
				if(!authorizatedRels.contains(list)) {error(label+i+" = literal",a,SeMLPackage.Literals.ASSIGNMENT__IND); ok=false;}
			}
			
			if(!ok) {Console.ErrPairLn(local_log, "Aborted. Unauthorized relation(s)."); return false;}
	
		}	

		//================================================================= Throw all errors, warnings and informations
        //=============================================================================================================

		var String fixAll; //flag to fix all problems
		var HashSet<FeaturePlace> fixAllEOs = new HashSet<FeaturePlace>(); //max 1 fix-all Quickfix per Feature Place
		var boolean hasErrors = false;
		
		for(ps : problems.entrySet){ //iterate every list of problems
			val DefaultFP = new FeaturePlace(m.imports.last, SeMLPackage.Literals.IMPORT__NAME);
			val FeaturePlace f = visibilityMap.getOrDefault(ps.key, DefaultFP); //each Alias translates to one FP
			var int cnt = 0;
			for(p : ps.value){
				//avoid repeated fix all for the DefaultFP, and for every FP inside this loop
				if(p.type == TypeE.SOLVED && !fixAllEOs.contains(f)){fixAllEOs.add(f); fixAll = "F";} else fixAll = "";
				
				//Arguments for Quickfix: SmartFlag, SolutionsArray
				val String[] args = newArrayOfSize(p.solutions.size+1);
				args.set(0, fixAll);
				for(var i=1; i<args.size; i++){
					args.set(i,p.solutions.get(i-1).join(",")); //Join unique solution with ","
				}
				
				switch (p.level) {
					case ERROR:  {error  (p.GetLabel,f.eo,f.sf,f.index,FIX_PROBLEM, args);hasErrors=true;}
					case WARNING:{warning(p.GetLabel,f.eo,f.sf,f.index,FIX_PROBLEM, args);}
					case INFO:	 {info   (p.GetLabel,f.eo,f.sf,f.index,FIX_PROBLEM, args);}
				}
			}
		}
		
		//========================================================================================== Display Statistics
        //=============================================================================================================
		
		val elapsedTime = System.currentTimeMillis() - startTime;
		val solutionsTime = (solutionsRuntime as float/elapsedTime * 100f) as int
		val searchTime = (searchRuntime as float/elapsedTime * 100f) as int
		val loadingTime = (elapsedLoadingTime as float/elapsedTime * 100f) as int
		val relativeTime = elapsedTime/1000 + "s (" + loadingTime + "% loading, " + searchTime + "% search, " + solutionsTime + "% solutions)";
		if(hasErrors){
			Console.OutPair(local_log, "Done. Model has errors.  "); Console.DebLn(relativeTime); 
			return false;	
		}
		
		Console.OutPair(local_log, "Done. Model is valid.  "); Console.DebLn(relativeTime); 
		return true;
	}
	

	/**
	 * Check characteristic imposed restrictions, individual restrictions & Reports
	 * @return true if excess errors exist
	 */
	def public static boolean CheckModelRestrictions(boolean skipFullTest, HashSet<List<String>> authorizatedRels){
		
		nextProblem = null; //Reset next problem (used by smart Quickfix)
		
		//Create database with the problems caused by individual class restrictions or model characteristics
		//Each entry has a key which represents the agent's Alias
		problems = new HashMap<String, ArrayList<Problem>>;
		
		//Start progress monitor
		var Progress pm = null;
		if(!skipFullTest){
			val int workload = CharacteristicsSolver.GetCharacteristicsSize + activeInds.size;
			pm = new Progress(workload, "Validating Model", "Checking consistency");
		}
		
		try {

			//------------------------------------------------- Check characteristic imposed restrictions
	
			for(OWLClass ch: CharacteristicsSolver.GetRequiredCharacteristics){
				if(!skipFullTest) pm.subTask = "Checking \"" + Ontologies.GetShortIRI(ch.IRI) + "\" imposed restrictions";
				val ArrayList<Problem> ps = MasterOntology.CheckModelRestrictions(ch); 
				if(!ps.empty) { //Problems exist
					if(skipFullTest) {if(FindNextProblem(ps)){ if(!skipFullTest) pm.stop(); return false;}} //Irrelevant return value
					problems.put(MasterOntology.cachedIRIs.get(ch.IRI.toString), ps); //no old entry is overwritten because ch is unique every time
				}
				if(!skipFullTest) pm.state++; //Thread.sleep(200); //yield
			}
			
			//If excess errors exist, skip further checks
			if(problems.entrySet.exists[e | e.value.exists[p | p.type==TypeE.CHAR_EXCESS]]) { if(!skipFullTest) pm.stop(); return true;}
			
			//------------------------------------------------- Check individual restrictions & Reports & unsolved upperProblems
	
			//Check if individuals that were created in Protégé meet their class's restrictions
			//Note: these defect errors are not detected before due to the Open World Assumption 
			
			for(Individual i: activeInds){
				if(!skipFullTest) pm.subTask = "Checking \"" + i.name + "\" restrictions and reports";
				var ArrayList<Problem> ps = MasterOntology.CheckRelationRestrictions(authorizatedRels, i.iri);
				if(skipFullTest) {if(FindNextProblem(ps)) { if(!skipFullTest) pm.stop(); return false;}}//Irrelevant return value
				MasterOntology.CheckReports(i.iri,ps); //add Reports
				
				if(!ps.empty) problems.put(i.name, ps); //no old entry is overwritten because i is unique every time
				if(!skipFullTest) pm.state++; //Thread.sleep(200); //yield
			}
				
		} catch (Exception exception) {
			pm.stop();
			throw exception;
		}
		
		return false;
	}
	
	
	/**
	 * Updates the infrastructure when a change to the model is made by the Quickfix
	 * @return fail message or null
	 */
	def public static String QuickFixUpdate(){
		val MainModel m = globalMainModel;
		val relationsList = EcoreUtil2.getAllContentsOfType(m, Relation);
		val assignmentsList =	EcoreUtil2.getAllContentsOfType(m, Assignment);
		
		//=================================================================================== Update active individuals
        //=============================================================================================================
        
		activeInds = new HashSet<Individual>(); //Create list of active individuals (static + referenced)
		globalImportModel.staticIndividuals.forEach[i | activeInds.add(i)]; //Add static individuals
        val freeRefIRIs = new HashSet<String>(); //Create list of free referenced individuals
        
		//Populate lists
		for(r : relationsList){
			activeInds.addAll(r.ind2); //add every referenced instance
			r.ind2.forEach[i| if(i instanceof FreeIndividual) freeRefIRIs.add(i.iri)];
		}
		
		//============================================================================================= Update ontology
        //=============================================================================================================
        
		//Load Master (with referenced individuals) and initialize OWLAPI objects
		try { 
			MasterOntology.loadMasterOntology(new File(Ontologies.GENfolder + Ontologies.masterNAME), freeRefIRIs);
		} catch (Exception e) { return "Model fix was aborted. Error loading master ontology file: " + e.message; }	
		
		MasterOntology.AddOPRelations(relationsList); //Add all OP relations to master ontology
		MasterOntology.AddDPRelations(assignmentsList); //Add all DP relations to master ontology
		
		if(!MasterOntology.CheckConsistency()) //Check for inconsistencies
			return "Model fix was aborted. Last insertion generated inconsistencies.";
		
		//------------------------------------------------- Update Characteristics tree and check it

		try {
			if(!MasterOntology.BuildMastersCharacteristicsTree(m.useCh)) return "Model fix was aborted. Unsolved Characteristics variabilites.";
		} catch (Exception e) {
			return "Model fix was aborted. Characteristics inconsistency.";
		}

		//------------------------------------------------- Add Characteristic individuals to ontology and check consistency (SWRL)
		
		MasterOntology.AddChIndividuals(CharacteristicsSolver.GetRequiredCharacteristics);
		
		if(!MasterOntology.CheckConsistency()) //Check for inconsistencies
			return "Model fix was aborted. Last insertion generated Characteristic inconsistencies.";
		
		return null;
	}
	

	
	/**
	 * Searches for a SOLVED Problem
	 * @return true if it is found
	 */
	def static boolean FindNextProblem(ArrayList<Problem> ps){
		
		for(p : ps) 
			if(p.type == TypeE.SOLVED){nextProblem = p; return true;} 
			
		return false;
	}
	
	
	/**
	 * Gets the available reports and throws errors and warning accordingly
	 */
	/*def void ReportAnomalies(MainModel m, List<Individual> individualsList){ 
		val String local_log = local_log + "[checkModel] ";
		var String issue = Anomaly.getErrors();
		if(issue !== null) {RouteIssueToAgent(m, issue, individualsList, 2);}
		issue = Anomaly.getWarnings();
		if(issue !== null) {RouteIssueToAgent(m, issue, individualsList, 3);}
		issue = Anomaly.getInfos();
		if(issue !== null) {RouteIssueToAgent(m, issue, individualsList, 4);}
	}*/
	
	/**
	 * Very basic function to dispatch the issue to its agent (uses every visible individual)
	 */
	def void RouteIssueToAgent(MainModel m, String issue, int type){
		for(Entry<String,FeaturePlace> i: visibilityMap.entrySet){
			if(issue.contains(i.key)){
				DisplayAnomalies(" (related with this individual):\n" + issue, i.value.eo, i.value.sf, i.value.index, type); 
				return;
			}
		}
		DisplayAnomalies(":\n" + issue, m.imports.last, SeMLPackage.Literals.IMPORT__NAME, ValidationMessageAcceptor.INSIGNIFICANT_INDEX, type);
	} 

	def void DisplayAnomalies(String s, EObject eo, EStructuralFeature eRef, int index, int type){
		switch (type) {
			case 1: {error("Anomaly" + s, eo, eRef, index);}
			case 2: {error("Error" + s, eo, eRef, index);}
			case 3: {warning("Warning" + s, eo, eRef, index);}
			case 4: {info("Information" + s, eo, eRef, index);}
		}
	}

	
	/**
	 * Load and parse ImportModel. This method loads the file on-demand
	 * if the model contains no cross-references.
	 * 
	 * @param contextResource		Absolute file path of the ImportsModel
	 * @param importURIAsString		Absolute file path of the ImportsModel
	 */

	def void GetImportModel(Resource contextResource, String importURIAsString) {
		
		var Resource resource = ImportResource(contextResource, importURIAsString);
		
		if(resource === null) {error("Error loading keywords file: " + Ontologies.GENfile.absolutePath, globalMainModel.imports.last, SeMLPackage.Literals.IMPORT__NAME);return;}
		
		if(!resource.timeStamp.equals(importDate)){ //Reload resource if modified
			resource.unload; //Unload
			resource = ImportResource(contextResource, importURIAsString); //Reload
		}
		
		globalImportModel = resource?.allContents?.head as ImportModel	
	}
	
	/**
	 *  Load Resource
	 */
	def static Resource ImportResource(Resource contextResource, String importURIAsString){
		
		val URI importURI = URI?.createURI(importURIAsString)
		val URI contextURI = contextResource?.getURI
		val URI resolvedURI = importURI?.resolve(contextURI)
		val ResourceSet contextResourceSet = contextResource?.resourceSet
		var Resource resource = contextResourceSet?.getResource(resolvedURI, true)
		return resource;
		
	}
	
	
	/**
	 * Auxiliary function of checkModel, to check imports and create the master ontology
	 * 
	 * @param m		MainModel
	 * @return		True if imports are valid 
	 */
	def boolean CheckImports(MainModel m){ //detects changes in Imported ontologies
		val String local_log = local_log + "[checkModelImports] ";
		var long mostRecentFile = 0;
    	
    	//Check if there are any imports
		if(m.imports.empty) return false;
		
		//Create imports paths list
		val String[] pathslist = newArrayOfSize(m.imports.length); var int cnt = 0;
		
		//Check if every file exists before proceeding
		for(i: m.imports){
			val File ontfile = new File(i.getName());
			if(!ontfile.exists || ontfile.isDirectory) {error("Ontology file was not found", i, SeMLPackage.Literals.IMPORT__NAME); return false;}
			if(mostRecentFile < ontfile.lastModified) mostRecentFile = ontfile.lastModified;
			pathslist.set(cnt++,i.getName());
		}
		Arrays.sort(pathslist); //Sort ontologies paths to compare them with the generated file's list
		
		//Check if generated file is up-to-date
		if(Ontologies.GENfile.exists && Ontologies.GENfile.file){ //Check if file exists
		
			//Check if generated file is older than the most recent ontology
			importDate = Ontologies.GENfile.lastModified;
			if(mostRecentFile.compareTo(importDate) < 0){
				
				try {
					//Check if every imported file matches exactly with the generated file summary
					val FileInputStream fis = new FileInputStream(Ontologies.GENfile); //Open generated file
					val BufferedReader br = new BufferedReader(new InputStreamReader(fis,"UTF-8")); //Construct BufferedReader from InputStreamReader			 
					
					var String line = br.readLine(); cnt = 0;
					var int SourceFilesNo = Integer.parseInt(line.substring(Ontologies.GENfirstline.length));
					var boolean different = false;
					
					if(pathslist.size == SourceFilesNo){ //Check if number of source files matches
						while ((line = br.readLine()) != "*/") { //Read every line until the end of the commentary
							if(!pathslist.get(cnt++).equals(line)) different = true;
						}
						if(!different) {
							val File masterfile = new File(Ontologies.GENfolder + Ontologies.masterNAME);
							if(masterfile.exists && masterfile.file) {br.close(); return true;}
							else Console.OutPairLn(local_log, "Master Ontology file was deleted. Creating a new one...");	
						}
						else Console.OutPairLn(local_log, "Ontology sources have changed. Updating DSL keywords...");	
						
					} else Console.OutPairLn(local_log, "Number of ontology sources has changed. Updating DSL keywords...");	
					
					br.close();
				} catch (Exception e) {
					Console.OutPairLn(local_log, "Error while reading generated file: " + e.message);
					Console.OutPairLn(local_log, "Repairing file...");		   	
				}
				
			} else Console.OutPairLn(local_log, "Changes in ontologies detected. Updating DSL keywords...");	
		} else Console.OutPairLn(local_log, "Importing DSL keywords for the first time...");
		
		try {
			Ontologies.ParseOntologies(pathslist); //If there are no errors, the file was generated
			importDate = Ontologies.GENfile.lastModified;
		} catch (IOException e) {
			System.out.println(local_log + e.message);
			error(e.message, m.imports.last, SeMLPackage.Literals.IMPORT__NAME); //Error while loading or parsing ontology
			return false;
		}   	
		return true;
	}
	
	
	def public static boolean PopulateQuickFixMap(MainModel m){
	
		//Generate paths for current SEML file and generated SEML file
		Ontologies.populatePaths(m);
		
		//Import keywords file
		val resource = ImportResource(m.eResource, Ontologies.GENfile_relpath);

		if(resource === null || !resource.errors.empty) return false;
		
		quickfixMap = new HashMap<String,EObject>();
		
		val impModel = resource?.allContents?.head as ImportModel;	
		impModel.staticIndividuals.forEach[i| quickfixMap.put(i.name, i)];
		impModel.individualOptions.forEach[i| quickfixMap.put(i.name, i)];
		impModel.objectProperties.forEach[o | quickfixMap.put(o.name, o)];
		impModel.characteristics.forEach[c | quickfixMap.put(c.name, c)];
		
		return true; //Return after populating quickfixMap
	}
	
}
